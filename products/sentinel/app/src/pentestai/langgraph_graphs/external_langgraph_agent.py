from __future__ import annotations
from typing import TypedDict, List, Dict, Any, Optional
import os, re, json, logging

logger = logging.getLogger(__name__)

try:
    from langgraph.graph import StateGraph, END
    HAVE_LANGGRAPH = True
except Exception:
    HAVE_LANGGRAPH = False

class State(TypedDict, total=False):
    repo_path: Optional[str]
    apk_path: Optional[str]
    plan: Dict[str, Any]
    results: List[Dict[str, Any]]
    artifacts: Dict[str, str]
    __llm: Any

SECRET_PATTERNS = {
    "Generic API Key": re.compile(r"(?i)(api[_-]?key|token)\s*[:=]\s*['\"][A-Za-z0-9_\-]{16,}['\"]"),
    "AWS Access Key": re.compile(r"AKIA[0-9A-Z]{16}"),
    "Google API Key": re.compile(r"AIza[0-9A-Za-z\-_]{35}"),
}
RISKY_FILES = (".env", "gradle.properties", "package.json", "AndroidManifest.xml", "Podfile", ".npmrc", ".netrc")

def _plan(state: State) -> State:
    s = dict(state)
    s["plan"] = {
        "tasks": ["collect_repo_metadata", "secret_scan", "static_checks", "code_review", "unit_test", "mobile_dynamic", "pentest", "assemble"]
    }
    s.setdefault("results", [])
    s.setdefault("artifacts", {})
    return s

def _collect_repo_metadata(state: State) -> State:
    s = dict(state)
    repo = s.get("repo_path")
    if repo and os.path.isdir(repo):
        files = []
        for root, _, fns in os.walk(repo):
            for fn in fns:
                rel = os.path.relpath(os.path.join(root, fn), repo)
                files.append(rel)
        s["artifacts"]["repo_metadata.json"] = json.dumps({"files": files[:500]}, indent=2)
    return s

def _secret_scan(state: State) -> State:
    s = dict(state)
    repo = s.get("repo_path")
    findings = []
    if repo and os.path.isdir(repo):
        for root, _, fns in os.walk(repo):
            for fn in fns:
                if os.path.basename(fn) in RISKY_FILES:
                    p = os.path.join(root, fn)
                    try:
                        with open(p, "r", encoding="utf-8", errors="ignore") as fh:
                            t = fh.read()
                        for name, rx in SECRET_PATTERNS.items():
                            if rx.search(t):
                                findings.append({"title": f"Secret: {name}", "severity": "high", "file": os.path.relpath(p, repo)})
                    except Exception:
                        pass
    s["results"].append({"title": "Secret Scan", "findings": findings})
    return s

def _static_checks(state: State) -> State:
    s = dict(state)
    repo = s.get("repo_path")
    findings = []
    if repo and os.path.isdir(repo):
        for fn in ("package.json", "requirements.txt", "pyproject.toml"):
            p = os.path.join(repo, fn)
            if os.path.exists(p):
                findings.append({"title": f"Dependency file: {fn}", "severity": "medium", "file": fn})
    s["results"].append({"title": "Static Checks", "findings": findings})
    return s

def _code_review(state: State) -> State:
    s = dict(state)
    llm = s.get("__llm")
    repo = s.get("repo_path") or ""
    prompt = [
        {"role": "system", "content": "You are a meticulous code security reviewer. Return a concise list of risks."},
        {"role": "user", "content": f"Review project at path: {repo}. List 3â€“5 potential risks with short rationales."}
    ]
    summary = llm.generate(prompt) if llm else "LLM not available."
    s["results"].append({"title": "LLM Code Review", "findings": [{"title": "LLM summary", "severity": "low", "description": summary}]})
    return s

def _unit_test(state: State) -> State:
    s = dict(state)
    s["results"].append({"title": "Unit Tests", "findings": []})
    return s

def _mobile_dynamic(state: State) -> State:
    s = dict(state)
    s["results"].append({"title": "Mobile Dynamic", "findings": []})
    return s

def _pentest(state: State) -> State:
    s = dict(state)
    s["results"].append({"title": "Pentest", "findings": []})
    return s

def _assemble(state: State) -> State:
    return state

def build_external_graph(llm):
    if HAVE_LANGGRAPH:
        g = StateGraph(State)
        g.add_node("plan", _plan)
        g.add_node("collect_repo_metadata", _collect_repo_metadata)
        g.add_node("secret_scan", _secret_scan)
        g.add_node("static_checks", _static_checks)
        g.add_node("code_review", _code_review)
        g.add_node("unit_test", _unit_test)
        g.add_node("mobile_dynamic", _mobile_dynamic)
        g.add_node("pentest", _pentest)
        g.add_node("assemble", _assemble)
        g.set_entry_point("plan")
        chain = ["collect_repo_metadata","secret_scan","static_checks","code_review","unit_test","mobile_dynamic","pentest","assemble"]
        cur = "plan"
        for nxt in chain:
            g.add_edge(cur, nxt)
            cur = nxt
        g.add_edge("assemble", END)
        app = g.compile()
        class Runner:
            def invoke(self, state: State) -> State:
                s = dict(state); s["__llm"] = llm
                return app.invoke(s)
            __call__ = invoke
        return Runner()

    # Fallback (no LangGraph installed)
    class SeqRunner:
        def invoke(self, state: State) -> State:
            s = _plan(dict(state))
            s["__llm"] = llm
            s = _collect_repo_metadata(s)
            s = _secret_scan(s)
            s = _static_checks(s)
            s = _code_review(s)
            s = _unit_test(s)
            s = _mobile_dynamic(s)
            s = _pentest(s)
            s = _assemble(s)
            return s
        __call__ = invoke
    return SeqRunner()
