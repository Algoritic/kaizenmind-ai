
from __future__ import annotations
from typing import TypedDict, List, Dict, Any, Optional, Annotated
import json
import operator

READ_ONLY_KEYS = ("repo_path", "apk_path", "llm")

def _strip_readonly_keys(output: Dict[str, Any] | None) -> Dict[str, Any]:
    if not output:
        return {}
    for k in READ_ONLY_KEYS:
        output.pop(k, None)
    return output

def _wrap_node(fn):
    def _inner(state: Dict[str, Any]) -> Dict[str, Any]:
        result = fn(state) or {}
        return _strip_readonly_keys(result)
    return _inner

try:
    from langgraph.graph import StateGraph, END
    HAVE_LANGGRAPH = True
except Exception:
    HAVE_LANGGRAPH = False

from pentestai.models.persona_results import (
    BasePersonaResult, CodeReviewResult, TestEngineerResult,
    SecurityAnalystResult, PentesterResult, Finding, severity_sort_key
)
from pentestai.tools.adapters import security_toolkit, test_toolkit, pentest_toolkit, code_quality_toolkit
from pentestai.langgraph_graphs.external_langgraph_agent import build_external_graph

class State(TypedDict, total=False):
    repo_path: Optional[str]
    apk_path: Optional[str]
    targets: Optional[List[str]]
    plan: Annotated[Dict[str, Any], operator.or_]
    persona_results: Annotated[List[BasePersonaResult], operator.add]
    artifacts: Annotated[Dict[str, str], operator.or_]
    final_report: Dict[str, Any]
    llm: Any

def node_planner(state: State) -> dict:
    state = dict(state)
    state["plan"] = {
        "tasks": ["static_analysis", "test_generation", "pentest_simulation"],
        "execution_model": "hybrid-parallel",
        "order": ["code_review", ["test_engineer", "security_analyst", "pentester"], "aggregate"],
    }
    state.setdefault("persona_results", [])
    state.setdefault("artifacts", {})
    return state

def node_code_reviewer(state: State) -> dict:
    state = dict(state)
    repo_path = state.get("repo_path")
    apk_path = state.get("apk_path")
    metrics, lint_findings = code_quality_toolkit.CodeQualityToolkit.compute_metrics(repo_path)
    findings = list(lint_findings)
    if apk_path:
        findings += security_toolkit.SecurityToolkit.run_apk_analysis(apk_path=apk_path, deep=False)
    result = CodeReviewResult(
        persona="Code Reviewer",
        summary="Repository & basic APK review completed.",
        findings=findings,
        artifacts=[],
        metrics=metrics,
    )
    state.setdefault("persona_results", []).append(result)
    return state

def node_test_engineer(state: State) -> dict:
    state = dict(state)
    repo_path = state.get("repo_path")
    apk_path = state.get("apk_path")
    findings: List[Finding] = []
    artifacts: List[str] = []
    if repo_path:
        findings += test_toolkit.TestToolkit.run_tests(repo_path=repo_path)
        artifacts += test_toolkit.TestToolkit.generate_smoke_tests(repo_path=repo_path)
    elif apk_path:
        artifacts.append("# APK instrumentation test stub")
        findings.append(Finding(title="APK test stub", description="APK instrumentation tests not yet implemented.", severity="low"))
    result = TestEngineerResult(
        persona="Test Engineer",
        summary="Test tooling executed (or stubbed) and smoke tests generated.",
        findings=findings,
        artifacts=artifacts,
        coverage=None,
        failed_tests=[]
    )
    state.setdefault("persona_results", []).append(result)
    return state

def node_security_analyst(state: State) -> dict:
    state = dict(state)
    repo_path = state.get("repo_path")
    apk_path = state.get("apk_path")
    findings: List[Finding] = []
    if repo_path:
        findings += security_toolkit.SecurityToolkit.run_static_scan(repo_path=repo_path)
        findings += security_toolkit.SecurityToolkit.run_secret_scan(repo_path=repo_path)
        findings += security_toolkit.SecurityToolkit.run_dep_audit(repo_path=repo_path)
    if apk_path:
        findings += security_toolkit.SecurityToolkit.run_apk_analysis(apk_path=apk_path, deep=True)
    result = SecurityAnalystResult(
        persona="Security Analyst",
        summary="Static & binary analysis completed (stubs / real tools where available).",
        findings=findings,
        artifacts=[f"{f.title}: {f.evidence or ''}" for f in findings if f.evidence],
        vulnerabilities=[{"count": len(findings)}]
    )
    state.setdefault("persona_results", []).append(result)
    return state

def node_pentester(state: State) -> dict:
    state = dict(state)
    repo_path = state.get("repo_path")
    apk_path = state.get("apk_path")
    findings = pentest_toolkit.PentestToolkit.run_baseline_dynamic_scan(
        repo_path=repo_path,
        apk_path=apk_path,
        api_deep=True,
        apk_deep=True
    )
    result = PentesterResult(
        persona="PenTester",
        summary="Dynamic baseline pentest executed (stubs for missing tooling).",
        findings=findings,
        artifacts=[],
        exploits=[],
        impact_summary="See findings for impact."
    )
    state.setdefault("persona_results", []).append(result)
    return state

def node_external_agent(state: State) -> dict:
    state = dict(state)
    llm = state.get("llm")
    if not llm:
        print("LLM not available for external agent. Skipping.")
        return state
    
    external_app = build_external_graph(llm)
    if not external_app:
        print("External Langgraph not available. Skipping.")
        return state
    
    external_state = external_app.invoke(state)
    
    # Extract findings from external_state and add to persona_results
    external_results = external_state.get("results", [])
    for res in external_results:
        if "findings" in res:
            for finding_data in res["findings"]:
                # Ensure finding_data has all required fields or provide defaults
                finding = Finding(
                    title=finding_data.get("title", "External Agent Finding"),
                    description=finding_data.get("description", ""),
                    severity=finding_data.get("severity", "medium"),
                    evidence=finding_data.get("evidence", ""),
                    file=finding_data.get("file", ""),
                    line=finding_data.get("line", None)
                )
                # Create a dummy persona result to hold these findings
                # This might need refinement based on how external agent results are structured
                external_persona_result = BasePersonaResult(
                    persona="External Agent",
                    summary=res.get("title", "External agent execution"),
                    findings=[finding],
                    artifacts=[]
                )
                state.setdefault("persona_results", []).append(external_persona_result)
    return state

def node_aggregate(state: State) -> dict:
    state = dict(state)
    prs: List[BasePersonaResult] = state.get("persona_results", [])
    all_findings: List[Finding] = []
    for pr in prs:
        all_findings.extend(pr.findings)
    counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
    for f in all_findings:
        if f.severity in counts: counts[f.severity] += 1
    all_sorted = sorted(all_findings, key=severity_sort_key)
    seen = set(); deduped: List[Finding] = []
    for f in all_sorted:
        key = (f.title, f.severity, getattr(f, "file", None))
        if key in seen: continue
        seen.add(key); deduped.append(f)
    final = {
        "project": state.get("repo_path") or state.get("apk_path") or "n/a",
        "id": "run-sample",
        "summary": counts,
        "sections": [pr.model_dump() for pr in prs],
        "artifacts": {
            "tests": [a for pr in prs for a in (pr.artifacts or []) if "test" in a.lower()],
            "reports": [a for pr in prs for a in (pr.artifacts or []) if "scan" in a.lower() or "report" in a.lower()],
            "logs": [a for pr in prs for a in (pr.artifacts or []) if "log" in a.lower()],
        },
        "metadata": state.get("plan", {}),
        "findings_ranked": [f.model_dump() for f in deduped],
    }
    state["final_report"] = final
    return state

def build_graph():
    if not HAVE_LANGGRAPH: return None
    graph = StateGraph(State)
    graph.add_node("planner", _wrap_node(node_planner))
    graph.add_node("code_reviewer", _wrap_node(node_code_reviewer))
    graph.add_node("test_engineer", _wrap_node(node_test_engineer))
    graph.add_node("security_analyst", _wrap_node(node_security_analyst))
    graph.add_node("pentester", _wrap_node(node_pentester))
    graph.add_node("external_agent", _wrap_node(node_external_agent))
    graph.add_node("aggregate", _wrap_node(node_aggregate))
    graph.set_entry_point("planner")
    graph.add_edge("planner", "code_reviewer")
    graph.add_edge("code_reviewer", "test_engineer")
    graph.add_edge("code_reviewer", "security_analyst")
    graph.add_edge("code_reviewer", "pentester")
    graph.add_edge("code_reviewer", "external_agent")
    graph.add_edge("test_engineer", "aggregate")
    graph.add_edge("security_analyst", "aggregate")
    graph.add_edge("pentester", "aggregate")
    graph.add_edge("external_agent", "aggregate")
    graph.add_edge("aggregate", END)
    return graph.compile()
