from typing import TypedDict, List, Dict, Any
import os, re, json, pathlib

class State(TypedDict, total=False):
    repo_path: str | None
    apk_path: str | None
    targets: List[str] | None
    plan: Dict[str, Any]
    results: List[Dict[str, Any]]
    artifacts: Dict[str, str]

SECRET_PATTERNS = {
    "Generic API Key": re.compile(r"(?i)(api[_-]?key|token)\s*[:=]\s*['\"][A-Za-z0-9_\-]{16,}['\"]"),
    "AWS Access Key": re.compile(r"AKIA[0-9A-Z]{16}"),
    "Google API Key": re.compile(r"AIza[0-9A-Za-z\-_]{35}"),
}

RISKY_FILES = (".env", "gradle.properties", "package.json", "AndroidManifest.xml", "Podfile", ".npmrc", ".netrc")

def _iter_files(root: str):
    for dirpath, _, filenames in os.walk(root):
        # skip large/vendor directories
        if any(x in dirpath for x in (".git", "node_modules", "build", "dist", ".venv", "__pycache__")):
            continue
        for fn in filenames:
            yield os.path.join(dirpath, fn)

def _collect_repo_metadata(repo: str) -> Dict[str, Any]:
    files = [fp for fp in _iter_files(repo)]
    exts: Dict[str, int] = {}
    for fp in files:
        ext = pathlib.Path(fp).suffix.lower() or "<none>"
        exts[ext] = exts.get(ext, 0) + 1
    return {"file_count": len(files), "by_ext": exts}

def _secret_scan(repo: str) -> List[Dict[str, Any]]:
    findings: List[Dict[str, Any]] = []
    for fp in _iter_files(repo):
        try:
            with open(fp, "r", encoding="utf-8", errors="ignore") as f:
                text = f.read()
        except Exception:
            continue
        for name, rx in SECRET_PATTERNS.items():
            if rx.search(text):
                findings.append({
                    "title": f"Potential secret: {name}",
                    "severity": "high",
                    "file": fp,
                    "recommendation": "Rotate the credential, remove from repo, and use a secrets manager.",
                })
    return findings

def _static_checks(repo: str) -> List[Dict[str, Any]]:
    findings: List[Dict[str, Any]] = []
    for fp in _iter_files(repo):
        base = os.path.basename(fp)
        if base in RISKY_FILES:
            findings.append({
                "title": f"Review sensitive config: {base}",
                "severity": "medium",
                "file": fp,
                "recommendation": "Ensure no hardcoded secrets, debug flags, or overly broad permissions.",
            })
    return findings

def build_review_graph(llm, use_langgraph: bool = False):
    class Runner:
        def invoke(self, state: State):
            state.setdefault("results", [])
            state.setdefault("artifacts", {})
            state["plan"] = {"tasks": ["collect_repo_metadata", "secret_scan", "static_checks"]}

            repo = state.get("repo_path")
            if not repo or not os.path.isdir(repo):
                state["results"].append({"title": "No repository provided", "findings": []})
                return state

            meta = _collect_repo_metadata(repo)
            state["artifacts"]["repo_metadata.json"] = json.dumps(meta, indent=2)

            findings: List[Dict[str, Any]] = []
            findings += _secret_scan(repo)
            findings += _static_checks(repo)

            state["results"].append({"title": "Repository Security Review", "findings": findings})
            return state
        __call__ = invoke
    return Runner()
